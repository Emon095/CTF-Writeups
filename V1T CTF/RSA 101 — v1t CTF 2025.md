
This is the writeup of a Crypto challenge which was in the v1t CTF 2025.

This was a crypto challenge from v1t CTF 2025. This is the prompt:

![](https://miro.medium.com/v2/resize:fit:875/1*H50eas4M-XW16uuI9WRj4w.png)

This is the script we were provided in the challenge:

` n = 31698460634924412577399959706905435239651  
 e = 65537  
 c = 23648999580642514140599125257944114844209`

Goal: Decrypt ciphertext c.

### Factor n

Trial division shows that 101 divides n

 `=> p = 101  
 => q = n / p = 313846144900241708687128313929756784551`

### Compute phi(n)

 `phi = (p-1)*(q-1) = 100 * 313846144900241708687128313929756784550  
 phi = 31384614490024170868712831392975678455000
`
### Compute private exponent d

` d = e^{-1} mod phi  
=> d = 15149971222460666029915912140442476213473
`
### Decrypt

 `m = c^d mod n = 8520595641234233889906203467245297960090  
 Hex(m) = 190a2f07690f57386bce37c08e09f1849a  
 Bytes = b'\x19\n/\x07i\x0fW8k\xce7\xc0\x8e\t\xf1\x84\x9a
`
### Recover readable message

` For k = 1:  
 M = m + n  
 => v1t{RSA_101_b4by}`

### I wrote this script:

```n = 31698460634924412577399959706905435239651  
e = 65537  
c = 23648999580642514140599125257944114844209  
  
  
p = 101  
q = 313846144900241708687128313929756784551  
phi = (p-1)*(q-1)  
  
from sympy import mod_inverse  
d = mod_inverse(e, phi)  
m = pow(c, d, n)  
  
for k in range(0, 100001):  
    candidate = m + k * n  
    h = hex(candidate)[2:]  
    if len(h) % 2:  
        h = '0' + h  
    b = bytes.fromhex(h)  
    printable = ''.join(chr(x) for x in b if 32 <= x <= 126)  
    if printable and all(32 <= x <= 126 for x in b):    
        print("k =", k, "->", b, "->", printable)

```
### Flag: v1t{RSA_101_b4by}